using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel.Composition.Hosting;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Text;
using DreamNetwork.PlatformServer.IO;
using DreamNetwork.PlatformServer.Logic;
using MsgPack;
using MsgPack.Serialization;

namespace DreamNetwork.PlatformServer.Networking
{
    public abstract class Message
    {
        // TODO: generate a message id for packets from client to server. ideally sequential or generated by client.

        // TODO: Implement plugin framework-like behavior for message serialization
        private static CompositionContainer _packetContainer;
        internal readonly List<Manager> HandledByManagers = new List<Manager>();

        protected static CompositionContainer PacketContainer
        {
            get
            {
                return _packetContainer ??
                       (_packetContainer =
                           new CompositionContainer(
                               new AggregateCatalog(new AssemblyCatalog(Assembly.GetExecutingAssembly()))));
            }
        }

        internal uint RequestId { get; set; }

        internal MessageDirection MessageDirections
        {
            get
            {
                return GetType().GetCustomAttributes(typeof (MessageAttribute), false)
                    .Cast<MessageAttribute>()
                    .Single()
                    .Directions;
            }
        }

        internal uint MessageTypeId
        {
            get
            {
                return GetType().GetCustomAttributes(typeof (MessageAttribute), false)
                    .Cast<MessageAttribute>()
                    .Single()
                    .Type;
            }
        }

        public bool HandledBy<T>()
        {
            return HandledByManagers.Any(m => m is T);
        }

        public bool HandledBy(Manager manager)
        {
            return HandledByManagers.Any(m => m == manager);
        }

        /// <summary>
        ///     Clones the given response with the request ID set to the request message's ID.
        /// </summary>
        /// <typeparam name="T">Response message type</typeparam>
        /// <param name="request">The request message from which to set the request ID</param>
        /// <param name="response">The response message to set the request ID on</param>
        /// <returns>Response message with changed request ID</returns>
        public static T CloneResponse<T>(Message request, T response) where T : Message
        {
            var msg = response.MemberwiseClone() as T;

            if (msg.MessageDirections != MessageDirection.ToClient)
                throw new InvalidOperationException();
            if (request.MessageDirections != MessageDirection.ToServer)
                throw new InvalidOperationException();

            msg.RequestId = request.RequestId;

            return msg;
        }

        /// <summary>
        ///     Serializes this message into a byte array.
        /// </summary>
        /// <returns>
        ///     Serialized message. Structure is 4 bytes request ID, 4 bytes message type ID and the rest is BSON-encoded
        ///     message body.
        /// </returns>
        public byte[] Serialize()
        {
            byte[] message;
            using (var ms = new MemoryStream())
            {
                using (
                    var mw = new EndianBinaryWriter(new BigEndianBitConverter(), new NonClosingStreamWrapper(ms),
                        Encoding.UTF8))
                {
                    // message header
                    mw.Write(RequestId); // req id (4 bytes, uint) [0 if background message]
                    mw.Write(MessageTypeId); // msg type (4 bytes, uint)
                    mw.Flush();

                    var type = GetType();
                    var msctx = new SerializationContext {SerializationMethod = SerializationMethod.Map};
                    if (type.GetProperties().Any())
                    {
                        var mser = msctx.GetSerializer(type);
                        mser.Pack(mw.BaseStream, this);
                    }
                    else
                    {
                        var mser = msctx.GetSerializer(typeof (object));
                        mser.Pack(mw.BaseStream, null);
                    }
                }

                message = ms.ToArray();
            }

            return message;
        }

        /// <summary>
        ///     Deserializes a message from a byte array.
        /// </summary>
        /// <param name="direction">The direction of the message.</param>
        /// <param name="data">The data to deserialize.</param>
        /// <returns>Deserialized message.</returns>
        // TODO: Implement conditions for direction and data
        public static Message Deserialize(MessageDirection direction, byte[] data)
        {
            using (var ms = new MemoryStream(data))
            {
                using (
                    var mr = new EndianBinaryReader(new BigEndianBitConverter(), new NonClosingStreamWrapper(ms),
                        Encoding.UTF8))
                {
                    var requestId = mr.ReadUInt32();
                    var typeId = mr.ReadUInt32();
                    var type = GetMessageTypeById(direction, typeId);
                    if (type == null)
                        throw new ProtocolViolationException(
                            string.Format("No class found to handle packet of type 0x{0:X8}", typeId));

                    Message msg;
                    if (type.GetProperties().Any())
                    {
                        var msctx = new SerializationContext { SerializationMethod = SerializationMethod.Map };
                        var mser = msctx.GetSerializer(type);
                        msg = mser.Unpack(mr.BaseStream) as Message;
                        msg = NormalizeDecodedObject(msg) as Message;
                    }
                    else
                    {
                        msg = Activator.CreateInstance(type) as Message;
                    }

                    if (msg == null)
                        return null;

                    msg.RequestId = requestId;
                    return msg;
                }
            }
        }

        private static object NormalizeDecodedObject(object obj)
        {
            var objType = obj.GetType();
            foreach (var objProp in objType
                .GetProperties()
                .Where(p => p.CanWrite && p.CanRead))
            {
                var objValue = NormalizeDecodedValue(objProp.GetValue(obj, null));
                objProp.SetValue(obj, objValue, null);
            }
            return obj;
        }

        private static object NormalizeDecodedValue(object objValue)
        {
            if (!(objValue is MessagePackObject))
            {
                if (objValue is IDictionary)
                    return NormalizeDecodedDictionary(objValue as IDictionary);
                if (objValue is Array)
                    return NormalizeDecodedArray(objValue as Array);

                return objValue;
            }

            var mpObj = (MessagePackObject) objValue;
            if (mpObj.IsArray)
            {
                // I wonder if char[] needs special treatment
                objValue = NormalizeDecodedArray(mpObj.ToObject() as Array);
            }
            else if (mpObj.IsDictionary /* = mpObj.IsMap */)
            {
                objValue = NormalizeDecodedDictionary(mpObj.AsDictionary());
            }
            else if (mpObj.IsList)
            {
                objValue = NormalizeDecodedList(mpObj.AsList());
            }
            else if (mpObj.IsRaw)
            {
                if (mpObj.UnderlyingType == typeof (string))
                {
                    objValue = mpObj.ToString();
                }
                else
                {
                    objValue = mpObj.AsBinary();
                }
            }
            else if (mpObj.IsNil)
            {
                objValue = null;
            }
            return NormalizeDecodedObject(objValue);
        }

        private static IList NormalizeDecodedList(IEnumerable<MessagePackObject> list)
        {
            var castDict = list.Select(i => NormalizeDecodedValue(i)).ToArray();
            var castType = castDict.Select(i => i.GetType()).FindEqualType();
            var ret = Activator.CreateInstance(typeof(List<>).MakeGenericType(castType)) as IList;
            foreach (var obj in castDict)
                ret.Add(obj);
            return ret;
        }

        private static IDictionary NormalizeDecodedDictionary(IDictionary dict)
        {
            if (dict is MessagePackObjectDictionary)
            {
                var boxedDict = dict as MessagePackObjectDictionary;
                var ret1 = (IDictionary) Activator.CreateInstance(
                    typeof (Dictionary<,>),
                    boxedDict.Select(t => t.Key.GetType()).FindEqualType(),
                    boxedDict.Select(t => t.Value.GetType()).FindEqualType());
                foreach (var item in boxedDict)
                    ret1.Add(NormalizeDecodedValue(item.Key), NormalizeDecodedValue(item.Value));
                return ret1;
            }

            var ret = (IDictionary) Activator.CreateInstance(dict.GetType());
            /*
                typeof (Dictionary<,>).MakeGenericType(
                    castDict.Select(i => i.Key.GetType()).FindEqualType(),
                    castDict.Select(i => i.Value.GetType()).FindEqualType()));
             */
            foreach (var item in dict.Keys
                .Cast<object>()
                .Select(k => new {Key = NormalizeDecodedValue(k), Value = NormalizeDecodedValue(dict[k])}))
            {
                ret.Add(item.Key, item.Value);
            }
            return ret;
        }

        private static Array NormalizeDecodedArray(Array arr)
        {
            var ret = arr.Clone() as Array;
            for (int i = 0; i < arr.Length; i++)
                ret.SetValue(NormalizeDecodedValue(arr.GetValue(i)), i);
            return ret;
        }

        public static Type GetMessageTypeById(MessageDirection direction, uint typeId)
        {
            return Assembly.GetExecutingAssembly().GetTypes().Single(t =>
            {
                if (!t.IsSubclassOf(typeof (Message)))
                    return false;
                var a = t.GetCustomAttributes(typeof (MessageAttribute), false).SingleOrDefault() as MessageAttribute;
                if (a == null)
                    return false;
                return a.Type == typeId && a.Directions == direction;
            });
        }
    }
}